export default {"version":"0.0.5","tocContent":"<ul><li><a href=\"/mfml.md\">View as Markdown</a></li><li><a href=\"https://github.com/smikhalevski/mfml#readme\">GitHub<span class=\"external\"></span></a></li><li><a href=\"https://smikhalevski.github.io/mfml/\">API docs<span class=\"external\"></span></a></li></ul><p><span class=\"toc-icon\">üî∞‚ÄÇ</span><a href=\"#quick-start\"><strong>Quick start</strong></a></p><ul><li><a href=\"#syntax-overview\">Syntax overview</a></li><li><a href=\"#arguments\">Arguments</a></li><li><a href=\"#types-and-styles\">Types and styles</a></li><li><a href=\"#options\">Options</a></li><li><a href=\"#categories\">Categories</a></li><li><a href=\"#pluralization\">Pluralization</a></li></ul><p><span class=\"toc-icon\">‚öõÔ∏è‚ÄÇ</span><strong>Rendering</strong></p><ul><li><a href=\"#render-to-string\">Render to string</a></li><li><a href=\"#react-integration\">React integration</a></li><li><a href=\"#custom-formatters\">Custom formatters</a></li></ul><p><span class=\"toc-icon\">‚öôÔ∏è‚ÄÇ</span><a href=\"#devtool\"><strong>Devtool</strong></a></p><p><span class=\"toc-icon\">üõ†Ô∏è‚ÄÇ</span><a href=\"#configuration\"><strong>Configuration</strong></a></p><ul><li><a href=\"#messages\"><code>messages</code></a></li><li><a href=\"#outdir\"><code>outDir</code></a></li><li><a href=\"#packagename\"><code>packageName</code></a></li><li><a href=\"#fallbacklocales\"><code>fallbackLocales</code></a></li><li><a href=\"#preprocessors\"><code>preprocessors</code></a></li><li><a href=\"#postprocessors\"><code>postprocessors</code></a></li><li><a href=\"#renamemessagefunction\"><code>renameMessageFunction</code></a></li><li><a href=\"#decodetext\"><code>decodeText</code></a></li><li><a href=\"#getargumenttstype\"><code>getArgumentTSType</code></a></li><li><a href=\"#tokenizeroptions\"><code>tokenizerOptions</code></a></li></ul><p><span class=\"toc-icon\">ü™µ‚ÄÇ</span><a href=\"#tokenizing-messages\"><strong>Tokenizing messages</strong></a></p><ul><li><a href=\"#voidtags\"><code>voidTags</code></a></li><li><a href=\"#rawtexttags\"><code>rawTextTags</code></a></li><li><a href=\"#implicitlyclosedtags\"><code>implicitlyClosedTags</code></a></li><li><a href=\"#implicitlyopenedtags\"><code>implicitlyOpenedTags</code></a></li><li><a href=\"#iscaseinsensitivetags\"><code>isCaseInsensitive‚ÄãTags</code></a></li><li><a href=\"#isselfclosingtagsrecognized\"><code>isSelfClosingTags‚ÄãRecognized</code></a></li><li><a href=\"#isunbalancedstarttagsimplicitlyclosed\"><code>isUnbalancedStart‚ÄãTags‚ÄãImplicitly‚ÄãClosed</code></a></li><li><a href=\"#isunbalancedendtagsignored\"><code>isUnbalancedEndTags‚ÄãIgnored</code></a></li><li><a href=\"#israwtextinterpolated\"><code>isRawText‚ÄãInterpolated</code></a></li><li><a href=\"#isoctothorperecognized\"><code>isOctothorpe‚ÄãRecognized</code></a></li></ul><p><span class=\"toc-icon\">üå≤‚ÄÇ</span><a href=\"#parsing-messages\"><strong>Parsing messages</strong></a></p><p><span class=\"toc-icon\">üéØ‚ÄÇ</span><a href=\"#motivation\"><strong>Motivation</strong></a></p>","articleContent":"<p>The <a href=\"https://unicode-org.github.io/icu/userguide/format_parse/messages/\">ICU MessageFormat<span class=\"external\"></span></a> + XML/HTML compiler and runtime that makes your i18n messages tree-shakeable.</p><ul><li>TypeScript-first.</li><li>Tree-shakeable: colocates messages with the code that uses them.</li><li>Integrates with any translation management system.</li><li>Highly customizable.</li><li>First-class React support.</li><li>Zero dependencies.</li><li>XSS-resilient: no dangerous HTML rendering.</li><li><a href=\"https://bundlephobia.com/result?p=mfml\">Just 2‚ÄØkB gzipped.<span class=\"external\"></span></a></li></ul><br><pre><code class=\"language-sh\">npm install --save-prod mfml\n</code></pre><br><h1 id=\"quick-start\"><a class=\"markdown-permalink\" href=\"#quick-start\"><span class=\"icon icon-link\"></span></a>Quick start</h1><p>Put your i18n messages in <em>messages.json</em>, grouped by locale:</p><pre><code class=\"language-json\">{\n  <span class=\"pl-ent\">\"en\"</span>: {\n    <span class=\"pl-ent\">\"greeting\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Hello, &#x3C;b>{name}&#x3C;/b>!<span class=\"pl-pds\">\"</span></span>\n  },\n  <span class=\"pl-ent\">\"ru\"</span>: {\n    <span class=\"pl-ent\">\"greeting\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>–ü—Ä–∏–≤–µ—Ç, &#x3C;b>{name}&#x3C;/b>!<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</code></pre><p>Put your <a href=\"#configuration\">config</a> in <em>mfml.config.js</em>:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defineConfig</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/compiler<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-smi\">messages</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>./messages.json<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">with</span> { type: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>json<span class=\"pl-pds\">'</span></span> };\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  <span class=\"pl-smi\">messages</span>,\n});\n</code></pre><p>Compile messages:</p><pre><code class=\"language-shell\">npx mfml\n</code></pre><p>This would create the <code>@mfml/messages</code> npm package in <em>node_modules</em> directory. You can configure the <a href=\"#packagename\">package name</a> and the <a href=\"#outdir\">output directory</a> to your liking.</p><p>In your application code, import message functions to produce formatted text:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">renderToString</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-en\">renderToString</span>({\n  message: <span class=\"pl-smi\">greeting</span>,\n  values: { name: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Bob<span class=\"pl-pds\">'</span></span> },\n  locale: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n});\n<span class=\"pl-c\">// ‚Æï 'Hello, Bob!'</span>\n</code></pre><p>Or render messages with React:</p><pre><code class=\"language-tsx\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">Message</span>, <span class=\"pl-smi\">MessageLocaleProvider</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/react<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-en\">App</span> <span class=\"pl-k\">=</span> () <span class=\"pl-k\">=></span> (\n  &#x3C;<span class=\"pl-c1\">MessageLocaleProvider</span> <span class=\"pl-e\">value</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>en-US<span class=\"pl-pds\">'</span></span><span class=\"pl-pse\">}</span>>\n    &#x3C;<span class=\"pl-c1\">Message</span>\n      <span class=\"pl-e\">message</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-smi\">greeting</span><span class=\"pl-pse\">}</span>\n      <span class=\"pl-e\">values</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span>{ name: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Bob<span class=\"pl-pds\">'</span></span> }<span class=\"pl-pse\">}</span>\n    />\n  &#x3C;/<span class=\"pl-c1\">MessageLocaleProvider</span>>\n);\n</code></pre><p>This renders markup with HTML elements:</p><pre><code class=\"language-html\">Hello, &#x3C;<span class=\"pl-ent\">b</span>>Bob&#x3C;/<span class=\"pl-ent\">b</span>>!\n</code></pre><p>Now, your bundler would do all the heavy lifting and colocate message functions with components that import them in the same chunk.</p><h2 id=\"syntax-overview\"><a class=\"markdown-permalink\" href=\"#syntax-overview\"><span class=\"icon icon-link\"></span></a>Syntax overview</h2><p>The MFML syntax is a hybrid of the <a href=\"https://unicode-org.github.io/icu/userguide/format_parse/messages/\">ICU MessageFormat<span class=\"external\"></span></a> syntax and XML/HTML.</p><p>ICU MessageFormat is a templating syntax designed for internationalized messages. It allows developers to insert variables and handle pluralization, gender, and selection logic in a locale-aware way. MFML supports all ICU MessageFormat features and allows you to customize and extend them.</p><p>Here's the basic <a href=\"#arguments\">argument syntax</a>:</p><pre><code>{name}\n</code></pre><p>Enable formatting by specifying data <a href=\"#types-and-styles\">type and style</a>:</p><pre><code>{age, number, integer}\n</code></pre><p>Select over <a href=\"#categories\">argument categories</a>:</p><pre><code>{gender, select,\n  male { He is a # }\n  female { She is a # }\n}\n</code></pre><p><a href=\"#pluralization\">Pluralization</a> is handled through argument categories as well:</p><pre><code>You have {messageCount, plural,\n  one { one message }\n  other { # messages }\n}\n</code></pre><p>MFML supports XML/HTML tags and attributes:</p><pre><code class=\"language-html\">Hello, &#x3C;<span class=\"pl-ent\">strong</span>>{name}&#x3C;/<span class=\"pl-ent\">strong</span>>!\n</code></pre><p>Arguments can be used where XML/HTML allows text:</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">abbr</span> <span class=\"pl-e\">title</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Greetings to {name}<span class=\"pl-pds\">\"</span></span>>Hello, {name}!&#x3C;/<span class=\"pl-ent\">abbr</span>>\n</code></pre><p>You can use your custom tags and setup a <a href=\"#custom-renderer\">custom renderer</a> to properly display them:</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">Hint</span> <span class=\"pl-e\">title</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Final offer at {discount, percent} discount!<span class=\"pl-pds\">\"</span></span>>{price}&#x3C;/<span class=\"pl-ent\">Hint</span>>\n</code></pre><h2 id=\"arguments\"><a class=\"markdown-permalink\" href=\"#arguments\"><span class=\"icon icon-link\"></span></a>Arguments</h2><p>The most basic use case is argument placeholder replacement:</p><pre><code>Hello, {name}!\n</code></pre><p>Here, <code>{name}</code> is an argument that doesn't impose any formatting on its value. Spaces around the argument name are ignored, so this yields the same result:</p><pre><code>Hello, {   name   }!\n</code></pre><p><a href=\"#custom-formatters\">By default</a>, during interpolation, the argument values are cast to string.</p><h2 id=\"types-and-styles\"><a class=\"markdown-permalink\" href=\"#types-and-styles\"><span class=\"icon icon-link\"></span></a>Types and styles</h2><p>Argument values can be formatted during interpolation. Provide an argument type to select the formatter to use:</p><pre><code>You have {count, number} messages.\n                 ^^^^^^\n</code></pre><p>Here, <code>number</code> is an argument type. <a href=\"#custom-formatters\">By default</a>, <code>number</code> type uses <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat\"><code>Intl.NumberFormat</code><span class=\"external\"></span></a> for formatting.</p><p>You can also provide a style for a formatter:</p><pre><code>Download {progress, number, percent} complete.\n                            ^^^^^^^\n</code></pre><p>Default configuration provides following argument types and styles:</p><table><tbody><tr><th align=\"left\">Argument¬†type</th><th align=\"left\">Argument¬†style</th><th align=\"left\">Example,¬†<code>en</code>¬†locale</th><th align=\"left\">Required¬†value¬†type</th></tr><tr><td valign=\"top\" rowspan=\"5\"><code>number</code></td><td>‚Äî</td><td>1,000.99</td><td valign=\"top\" rowspan=\"5\"><code>number</code> or <code>bigint</code></td></tr><tr><td><code>decimal</code></td><td>1,000.99</td></tr><tr><td><code>integer</code></td><td>1,000</td></tr><tr><td><code>percent</code></td><td>75%</td></tr><tr><td><code>currency</code></td><td>$1,000.00</td></tr><tr><td valign=\"top\" rowspan=\"5\"><code>date</code></td><td>‚Äî</td><td>1/1/1970</td><td valign=\"top\" rowspan=\"5\"><code>number</code> or <code>Date</code></td></tr><tr><td><code>short</code></td><td>1/1/70</td></tr><tr><td><code>medium</code></td><td>Jan‚ÄØ1,‚ÄØ1970</td></tr><tr><td><code>long</code></td><td>January‚ÄØ1,‚ÄØ1970</td></tr><tr><td><code>full</code></td><td>Thursday,‚ÄØJanuary‚ÄØ1,‚ÄØ1970</td></tr><tr><td valign=\"top\" rowspan=\"5\"><code>time</code></td><td>‚Äî</td><td>12:00¬†AM</td><td valign=\"top\" rowspan=\"5\"><code>number</code> or <code>Date</code></td></tr><tr><td><code>short</code></td><td>12:00¬†AM</td></tr><tr><td><code>medium</code></td><td>12:00:00¬†AM</td></tr><tr><td><code>long</code></td><td>12:00:00¬†AM¬†UTC</td></tr><tr><td><code>full</code></td><td>12:00:00¬†AM¬†Coordinated¬†Universal¬†Time</td></tr><tr><td valign=\"top\" rowspan=\"4\"><code>conjunction</code></td><td>‚Äî</td><td>A, B, and C</td><td valign=\"top\" rowspan=\"4\"><code>string[]</code></td></tr><tr><td><code>narrow</code></td><td>A, B, C</td></tr><tr><td><code>short</code></td><td>A, B, &#x26; C</td></tr><tr><td><code>long</code></td><td>A, B, and C</td></tr><tr><td valign=\"top\" rowspan=\"4\"><code>disjunction</code></td><td>‚Äî</td><td>A, B, or C</td><td valign=\"top\" rowspan=\"4\"><code>string[]</code></td></tr><tr><td><code>narrow</code></td><td>A, B, or C</td></tr><tr><td><code>short</code></td><td>A, B, or C</td></tr><tr><td><code>long</code></td><td>A, B, or C</td></tr></tbody></table><h2 id=\"options\"><a class=\"markdown-permalink\" href=\"#options\"><span class=\"icon icon-link\"></span></a>Options</h2><p>Instead of using a predefined style, you can provide a set of options for a formatter:</p><pre><code>{propertyArea, number,\n  style=unit\n  unit=acre\n  unitDisplay=long\n}\n</code></pre><p>Here <code>style</code>, <code>unit</code> and <code>unitDisplay</code> are options of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat\"><code>Intl.NumberFormat</code><span class=\"external\"></span></a>.</p><p>You can find the full list of options for <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#style_options\"><code>number</code> arguments<span class=\"external\"></span></a> and for <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#locale_options\"><code>date</code> and <code>time</code> arguments<span class=\"external\"></span></a> on MDN.</p><h2 id=\"categories\"><a class=\"markdown-permalink\" href=\"#categories\"><span class=\"icon icon-link\"></span></a>Categories</h2><p>Arguments can use categories for conditional rendering. For example, if you want to alter a message depending on a user's gender:</p><pre><code>{gender, select,\n  male {He}\n  female {She}\n  other {They}\n}\nsent you a message.\n</code></pre><p>Value of the <code>gender</code> argument is used for selecting a specific category. If the value is <code>\"male\"</code> then argument placeholder is replaced with \"He\", if value is <code>\"female\"</code> then with \"She\", and for any other value \"They\" is rendered.</p><p><code>other</code> is a special category: its value is used if no other category matches. If there's no matching category in <code>select</code> and no <code>other</code> category, the argument placeholder is replaced with an empty string.</p><p>It is recommended to always provide the <code>other</code> category as a fallback.</p><h2 id=\"pluralization\"><a class=\"markdown-permalink\" href=\"#pluralization\"><span class=\"icon icon-link\"></span></a>Pluralization</h2><p>Numeric argument values can be pluralized in cardinal and ordinal fashion.</p><p>Use <code>plural</code> argument type for cardinal pluralization rules:</p><pre><code>You have {messageCount, plural,\n  one {one message}\n  other {# messages}\n}.\n</code></pre><p>Following cardinal categories are supported with <code>plural</code>:</p><dl><dt>zero</dt><dd><p>This category is used for languages that have grammar specialized specifically for zero number of items. (Examples are Arabic and Latvian.)</p></dd><dt>one</dt><dd><p>This category is used for languages that have grammar specialized specifically for one (singular) item. Many languages, but not all, use this plural category. (Many popular Asian languages, such as Chinese and Japanese, do not use this category.)</p></dd><dt>two</dt><dd><p>This category is used for languages that have grammar specialized specifically for two (dual) items. (Examples are Arabic and Welsh.)</p></dd><dt>few</dt><dd><p>This category is used for languages that have grammar specialized specifically for a small number (paucal) of items. For some languages this is used for 2-4 items, for some 3-10 items, and other languages have even more complex rules.</p></dd><dt>many</dt><dd><p>This category is used for languages that have grammar specialized specifically for a larger number of items. (Examples are Arabic, Polish, and Russian.)</p></dd><dt>other</dt><dd><p>This category is used if the value doesn't match one of the other plural categories. Note that this is used for <code>plural</code> for languages (such as English) that have a simple \"singular\" versus \"plural\" dichotomy.</p></dd></dl><p>Use <code>selectOrdinal</code> argument type for ordinal pluralization rules:</p><pre><code>You have finished {position, selectOrdinal,\n  one {#st}\n  two {#nd}\n  few {#rd}\n  other {#th}\n}.\n</code></pre><p>Following ordinal categories are supported with <code>selectOrdinal</code>:</p><dl><dt>zero</dt><dd><p>This category is used for languages that have grammar specialized specifically for zero number of items. (Examples are Arabic and Latvian.)</p></dd><dt>one</dt><dd><p>This category is used for languages that have grammar specialized specifically for one item. Many languages, but not all, use this plural category. (Many popular Asian languages, such as Chinese and Japanese, do not use this category.)</p></dd><dt>two</dt><dd><p>This category is used for languages that have grammar specialized specifically for two items. (Examples are Arabic and Welsh.)</p></dd><dt>few</dt><dd><p>This category is used for languages that have grammar specialized specifically for a small number of items. For some languages this is used for 2-4 items, for some 3-10 items, and other languages have even more complex rules.</p></dd><dt>many</dt><dd><p>This category is used for languages that have grammar specialized specifically for a larger number of items. (Examples are Arabic, Polish, and Russian.)</p></dd><dt>other</dt><dd><p>This category is used if the value doesn't match one of the other plural categories. Note that this is used for <code>plural</code> for languages (such as English) that have a simple \"singular\" versus \"plural\" dichotomy.</p></dd></dl><p>You can use the special token (<code>#</code>, aka octothorpe) as a placeholder inside a category. By default, both <code>plural</code> and <code>selectOrdinal</code> argument types format <code>#</code> using <a href=\"#types-and-styles\"><code>number</code> argument type without style</a>.</p><p>If you want apply a specific formatting, use an explicit argument instead of an octothorpe:</p><pre><code>You have {messageCount, plural,\n  one {one message}\n  other {{messageCount, number, useGrouping=false} messages}\n}.\n</code></pre><p>Both <code>plural</code> and <code>selectOrdinal</code> support literal value matching. Prefix a value with an equals character <code>=</code>:</p><pre><code>You have {messageCount, plural,\n  =0 {no messages}\n  one {one message}\n  other {# messages}\n}.\n</code></pre><h1 id=\"render-to-string\"><a class=\"markdown-permalink\" href=\"#render-to-string\"><span class=\"icon icon-link\"></span></a>Render to string</h1><p>Render messages as plain text using <a href=\"https://smikhalevski.github.io/mfml/functions/mfml.renderToString.html\"><code>renderToString</code><span class=\"external\"></span></a>:</p><p>For example if you compiled a message:</p><pre><code class=\"language-json\">{\n  <span class=\"pl-ent\">\"en\"</span>: {\n    <span class=\"pl-ent\">\"greeting\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Hello, &#x3C;b>{name}&#x3C;/b>!<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</code></pre><p>Then you can render it to string:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">renderToString</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-en\">renderToString</span>({\n  message: <span class=\"pl-smi\">greeting</span>,\n  values: { name: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Bob<span class=\"pl-pds\">'</span></span> },\n  locale: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n});\n<span class=\"pl-c\">// ‚Æï 'Hello, Bob!'</span>\n</code></pre><p>By default, <code>renderToString</code> doesn't render tags and outputs only their contents. It also ignores tags that aren't lowercase alpha: these are considered custom tags. You can change this behavior by providing a custom renderer:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defaultArgumentFormatter</span>, <span class=\"pl-smi\">defaultCategorySelector</span>, <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Renderer</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">myRenderer</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Renderer</span>&#x3C;<span class=\"pl-c1\">string</span>> <span class=\"pl-k\">=</span> {\n  <span class=\"pl-en\">renderElement</span>(<span class=\"pl-v\">tagName</span>, <span class=\"pl-v\">attributes</span>, <span class=\"pl-v\">children</span>) {\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">tagName</span> <span class=\"pl-k\">===</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">?</span> <span class=\"pl-s\"><span class=\"pl-pds\">`</span>__${<span class=\"pl-smi\">children</span>.<span class=\"pl-c1\">join</span>(<span class=\"pl-pds\">''</span>)}__<span class=\"pl-pds\">`</span></span> <span class=\"pl-k\">:</span> <span class=\"pl-smi\">children</span>.<span class=\"pl-c1\">join</span>(<span class=\"pl-s\"><span class=\"pl-pds\">''</span></span>);\n  },\n\n  formatArgument: <span class=\"pl-smi\">defaultArgumentFormatter</span>,\n  selectCategory: <span class=\"pl-smi\">defaultCategorySelector</span>,\n};\n\n<span class=\"pl-en\">renderToString</span>({\n  message: <span class=\"pl-smi\">greeting</span>,\n  values: { name: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Bob<span class=\"pl-pds\">'</span></span> },\n  locale: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n  renderer: <span class=\"pl-smi\">myRenderer</span>,\n});\n<span class=\"pl-c\">// ‚Æï 'Hello, __Bob__!'</span>\n</code></pre><h1 id=\"react-integration\"><a class=\"markdown-permalink\" href=\"#react-integration\"><span class=\"icon icon-link\"></span></a>React integration</h1><p>MFML provides a set of components to render compiled i18n message function with React.</p><p>For example if you compiled a message:</p><pre><code class=\"language-json\">{\n  <span class=\"pl-ent\">\"en\"</span>: {\n    <span class=\"pl-ent\">\"greeting\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Hello, &#x3C;b>{name}&#x3C;/b>!<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</code></pre><p>Then you can render it with React using <a href=\"https://smikhalevski.github.io/mfml/functions/mfml_react.Message.html\"><code>&#x3C;Message></code><span class=\"external\"></span></a> component:</p><pre><code class=\"language-tsx\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">Message</span>, <span class=\"pl-smi\">MessageLocaleProvider</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/react<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-en\">App</span> <span class=\"pl-k\">=</span> () <span class=\"pl-k\">=></span> (\n  &#x3C;<span class=\"pl-c1\">MessageLocaleProvider</span> <span class=\"pl-e\">value</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span><span class=\"pl-pse\">}</span>>\n    &#x3C;<span class=\"pl-c1\">Message</span>\n      <span class=\"pl-e\">message</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-smi\">greeting</span><span class=\"pl-pse\">}</span>\n      <span class=\"pl-e\">values</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span>{ name: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Bob<span class=\"pl-pds\">'</span></span> }<span class=\"pl-pse\">}</span>\n    />\n  &#x3C;/<span class=\"pl-c1\">MessageLocaleProvider</span>>\n);\n</code></pre><p>This would output:</p><pre><code class=\"language-html\">Hello, &#x3C;<span class=\"pl-ent\">b</span>>Bob&#x3C;/<span class=\"pl-ent\">b</span>>!\n</code></pre><p>If argument doesn't have a <a href=\"#types-and-styles\">type specified</a>, then you can pass an arbitrary React markup as its value:</p><pre><code class=\"language-tsx\">&#x3C;<span class=\"pl-c1\">Message</span>\n  <span class=\"pl-e\">message</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-smi\">greeting</span><span class=\"pl-pse\">}</span>\n  <span class=\"pl-e\">values</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span>{ name: &#x3C;<span class=\"pl-c1\">Cool</span>>Bob&#x3C;/<span class=\"pl-c1\">Cool</span>> }<span class=\"pl-pse\">}</span>\n/>\n</code></pre><p>This would output:</p><pre><code class=\"language-html\">Hello, &#x3C;<span class=\"pl-ent\">b</span>>&#x3C;<span class=\"pl-ent\">Cool</span>>Bob&#x3C;/<span class=\"pl-ent\">Cool</span>>&#x3C;/<span class=\"pl-ent\">b</span>>!\n</code></pre><h2 id=\"custom-renderer\"><a class=\"markdown-permalink\" href=\"#custom-renderer\"><span class=\"icon icon-link\"></span></a>Custom renderer</h2><p>By default, <code>&#x3C;Message></code> only renders tags that are lowercase alpha. Other tags are considered custom tags. You can provide a custom renderer to support custom tags:</p><pre><code class=\"language-tsx\"><span class=\"pl-k\">import</span> { <span class=\"pl-k\">type</span> <span class=\"pl-smi\">ReactNode</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>react<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defaultArgumentFormatter</span>, <span class=\"pl-smi\">defaultCategorySelector</span>, <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Renderer</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">createReactDOMElementRenderer</span>, <span class=\"pl-smi\">Message</span>, <span class=\"pl-smi\">MessageLocaleProvider</span>, <span class=\"pl-smi\">MessageRendererProvider</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/react<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-c\">// 1Ô∏è‚É£ Create a custom component</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">Hint</span>(<span class=\"pl-v\">props</span><span class=\"pl-k\">:</span> { <span class=\"pl-v\">text</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">string</span>; <span class=\"pl-v\">children</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">ReactNode</span> }) {\n  <span class=\"pl-k\">return</span> &#x3C;<span class=\"pl-ent\">div</span> <span class=\"pl-e\">title</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-smi\">props</span>.<span class=\"pl-c1\">text</span><span class=\"pl-pse\">}</span>><span class=\"pl-pse\">{</span><span class=\"pl-smi\">props</span>.<span class=\"pl-smi\">children</span><span class=\"pl-pse\">}</span>&#x3C;/<span class=\"pl-ent\">div</span>>;\n}\n\n<span class=\"pl-c\">// 2Ô∏è‚É£ Create a custom renderer</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">myRenderer</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Renderer</span>&#x3C;<span class=\"pl-c1\">string</span>> <span class=\"pl-k\">=</span> {\n  renderElement: <span class=\"pl-en\">createReactDOMElementRenderer</span>({\n    <span class=\"pl-smi\">Hint</span>,\n  }),\n  formatArgument: <span class=\"pl-smi\">defaultArgumentFormatter</span>,\n  selectCategory: <span class=\"pl-smi\">defaultCategorySelector</span>,\n};\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-en\">App</span> <span class=\"pl-k\">=</span> () <span class=\"pl-k\">=></span> (\n  <span class=\"pl-c\">// 3Ô∏è‚É£ Provide renderer through the context</span>\n  &#x3C;<span class=\"pl-c1\">MessageRendererProvider</span> <span class=\"pl-e\">value</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-smi\">myRenderer</span><span class=\"pl-pse\">}</span>>\n    &#x3C;<span class=\"pl-c1\">MessageLocaleProvider</span> <span class=\"pl-e\">value</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span><span class=\"pl-pse\">}</span>><span class=\"pl-pse\">{</span><span class=\"pl-c\">/* Render messages here */</span><span class=\"pl-pse\">}</span>&#x3C;/<span class=\"pl-c1\">MessageLocaleProvider</span>>\n  &#x3C;/<span class=\"pl-c1\">MessageRendererProvider</span>>\n);\n</code></pre><p>Now you can use <code>&#x3C;Hint></code> component in your i18n messages:</p><pre><code class=\"language-json\">{\n  <span class=\"pl-ent\">\"en\"</span>: {\n    <span class=\"pl-ent\">\"finalOffer\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Final offer: &#x3C;Hint text='{discount, percent} discount!'>{price, currency}&#x3C;/Hint><span class=\"pl-pds\">\"</span></span>\n  }\n}\n</code></pre><p>Render the compiled message function:</p><pre><code class=\"language-tsx\">&#x3C;<span class=\"pl-c1\">Message</span>\n  <span class=\"pl-e\">message</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span><span class=\"pl-smi\">finalOffer</span><span class=\"pl-pse\">}</span>\n  <span class=\"pl-e\">values</span><span class=\"pl-k\">=</span><span class=\"pl-pse\">{</span>{ discount: <span class=\"pl-c1\">0.2</span>, price: <span class=\"pl-c1\">1000</span> }<span class=\"pl-pse\">}</span>\n/>\n</code></pre><p>This would output:</p><pre><code class=\"language-html\">Final offer:\n&#x3C;<span class=\"pl-ent\">div</span> <span class=\"pl-e\">title</span>=<span class=\"pl-s\"><span class=\"pl-pds\">'</span>20% discount!<span class=\"pl-pds\">'</span></span>>$1,000&#x3C;/<span class=\"pl-ent\">div</span>>\n</code></pre><h1 id=\"custom-formatters\"><a class=\"markdown-permalink\" href=\"#custom-formatters\"><span class=\"icon icon-link\"></span></a>Custom formatters</h1><p>MFML provides the <a href=\"https://smikhalevski.github.io/mfml/variables/mfml.defaultArgumentFormatter.html\"><code>defaultArgumentFormatter</code><span class=\"external\"></span></a> that supports <code>number</code>, <code>date</code>, <code>time</code>, <code>conjunction</code> and <code>disjunction</code> argument types and <a href=\"#types-and-styles\">corresponding styles</a>.</p><p>To change how formatters are applied, you should create a custom renderer and provide it to <a href=\"#render-to-string\"><code>renderToString</code></a> or to <a href=\"#react-integration\"><code>&#x3C;Message></code></a> component (as a prop or through a <a href=\"https://smikhalevski.github.io/mfml/variables/mfml_react.MessageRendererProvider.html\"><code>&#x3C;MessageRendererProvider></code><span class=\"external\"></span></a>).</p><p>Let's assume we've compiled the function which is called <code>randomFact</code> for the following message:</p><pre><code>USA border length is {borderLength, unitMeter}.\n                                    ^^^^^^^^^\n</code></pre><p>Here, <code>unitMeter</code> is a custom type. Now, let's create a formatter that formats arguments with this type:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-k\">type</span> <span class=\"pl-smi\">ArgumentFormatter</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">unitMeterArgumentFormatter</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">ArgumentFormatter</span> <span class=\"pl-k\">=</span> <span class=\"pl-v\">params</span> <span class=\"pl-k\">=></span> {\n  <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">params</span>.<span class=\"pl-c1\">type</span> <span class=\"pl-k\">===</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>unitMeter<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">&#x26;&#x26;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">params</span>.<span class=\"pl-c1\">value</span> <span class=\"pl-k\">===</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>number<span class=\"pl-pds\">'</span></span>) {\n    <span class=\"pl-k\">const</span> <span class=\"pl-c1\">numberFormat</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-c1\">Intl</span>.<span class=\"pl-en\">NumberFormat</span>(<span class=\"pl-smi\">params</span>.<span class=\"pl-smi\">locale</span>, {\n      style: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>unit<span class=\"pl-pds\">'</span></span>,\n      unit: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>meter<span class=\"pl-pds\">'</span></span>,\n    });\n\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">numberFormat</span>.<span class=\"pl-en\">format</span>(<span class=\"pl-smi\">params</span>.<span class=\"pl-c1\">value</span>);\n  }\n\n  <span class=\"pl-k\">return</span> <span class=\"pl-smi\">params</span>.<span class=\"pl-c1\">value</span>;\n};\n</code></pre><p>Now, lets crete a string renderer that uses this formatter:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defaultArgumentFormatter</span>, <span class=\"pl-smi\">defaultCategorySelector</span>, <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Renderer</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">myRenderer</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Renderer</span>&#x3C;<span class=\"pl-c1\">string</span>> <span class=\"pl-k\">=</span> {\n  <span class=\"pl-en\">renderElement</span>: (<span class=\"pl-v\">tagName</span>, <span class=\"pl-v\">attributes</span>, <span class=\"pl-v\">children</span>) <span class=\"pl-k\">=></span> <span class=\"pl-smi\">children</span>.<span class=\"pl-c1\">join</span>(<span class=\"pl-s\"><span class=\"pl-pds\">''</span></span>),\n\n  <span class=\"pl-c\">// üü° Pass a custom formatter</span>\n  formatArgument: <span class=\"pl-smi\">unitMeterArgumentFormatter</span>,\n  selectCategory: <span class=\"pl-smi\">defaultCategorySelector</span>,\n};\n</code></pre><p>Render a message to string using this custom renderer:</p><pre><code class=\"language-ts\"><span class=\"pl-en\">renderToString</span>({\n  message: <span class=\"pl-smi\">randomFact</span>,\n  values: { borderLength: <span class=\"pl-c1\">8_891_000</span> },\n  locale: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n\n  <span class=\"pl-c\">// üü° Pass a custom renderer</span>\n  renderer: <span class=\"pl-smi\">myRenderer</span>,\n});\n<span class=\"pl-c\">// ‚Æï 'USA border length is 8,891,000 m.'</span>\n</code></pre><p>Usually, you want multiple formatters to be available, so MFML provides factories that simplify formatter declarations:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">combineArgumentFormatters</span>, <span class=\"pl-smi\">createNumberArgumentFormatter</span>, <span class=\"pl-smi\">createDateTimeArgumentFormatter</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">myArgumentFormatter</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">combineArgumentFormatters</span>([\n  <span class=\"pl-smi\">unitMeterArgumentFormatter</span>,\n\n  <span class=\"pl-en\">createNumberArgumentFormatter</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>number<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>decimal<span class=\"pl-pds\">'</span></span>),\n  <span class=\"pl-en\">createNumberArgumentFormatter</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>number<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>integer<span class=\"pl-pds\">'</span></span>, { maximumFractionDigits: <span class=\"pl-c1\">0</span> }),\n\n  <span class=\"pl-en\">createDateTimeArgumentFormatter</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>date<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>short<span class=\"pl-pds\">'</span></span>, { dateStyle: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>short<span class=\"pl-pds\">'</span></span> }),\n]);\n</code></pre><p><a href=\"https://smikhalevski.github.io/mfml/functions/mfml.combineArgumentFormatters.html\"><code>combineArgumentFormatters</code><span class=\"external\"></span></a> creates an argument formatter that sequentially applies each formatter from the list of formatters until one returns a formatted value. If none of the formatters returns a formatted value, then a value returned as-is.</p><p>Of you can fallback to a default formatter:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">combineArgumentFormatters</span>, <span class=\"pl-smi\">defaultArgumentFormatter</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">myArgumentFormatter</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">combineArgumentFormatters</span>([\n  <span class=\"pl-smi\">unitMeterArgumentFormatter</span>,\n  <span class=\"pl-smi\">defaultArgumentFormatter</span>,\n]);\n</code></pre><h1 id=\"devtool\"><a class=\"markdown-permalink\" href=\"#devtool\"><span class=\"icon icon-link\"></span></a>Devtool</h1><p>MFML provides the devtool for React DOM applications. To enable it, call <a href=\"https://smikhalevski.github.io/mfml/functions/mfml_react.enableDevtool.html\"><code>enableDevtool</code><span class=\"external\"></span></a> anywhere in your client-side code (on the server-side it is a no-op):</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">enableDevtool</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/react<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">debugInfo</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages/metadata<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-en\">enableDevtool</span>(<span class=\"pl-smi\">debugInfo</span>);\n</code></pre><p>Here <a href=\"#packagename\"><code>@mfml/messages</code></a> is a package generated by the <code>mfml</code> compiler. The exported <code>debugInfo</code> may have substantial size, so it is recommended to split it into a separate chunk:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">enableDevtool</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/react<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">import</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages/metadata<span class=\"pl-pds\">'</span></span>).<span class=\"pl-c1\">then</span>(<span class=\"pl-v\">module</span> <span class=\"pl-k\">=></span> <span class=\"pl-en\">enableDevtool</span>(<span class=\"pl-c1\">module</span>.<span class=\"pl-smi\">debugInfo</span>));\n</code></pre><p>To use the devtool, press and hold the <kbd>Alt</kbd> key (or <kbd>Option</kbd> key on Mac), then hover over a rendered message text to reveal the related message information.</p><h1 id=\"configuration\"><a class=\"markdown-permalink\" href=\"#configuration\"><span class=\"icon icon-link\"></span></a>Configuration</h1><p>When running <code>mfml</code> from the command line, MFML will automatically try to resolve a config file named <em>mfml.config.js</em> inside the <code>cwd</code> (other JS and TS extensions are also supported).</p><p>The most basic config file looks like this:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defineConfig</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/compiler<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    <span class=\"pl-c\">// Your i18n messages go here, grouped by locale</span>\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n});\n</code></pre><p>You can also explicitly specify a config file to use with the <code>--config</code> CLI option (resolved relative to <code>cwd</code>):</p><pre><code class=\"language-shell\">mfml --config my-config.js\n</code></pre><h2 id=\"messages\"><a class=\"markdown-permalink\" href=\"#messages\"><span class=\"icon icon-link\"></span></a><code>messages</code></h2><p>Messages arranged by a locale.</p><pre><code class=\"language-json5\">{\n  en<span class=\"pl-k\">:</span> {\n    greeting<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello<span class=\"pl-pds\">'</span></span>,\n  },\n  ru<span class=\"pl-k\">:</span> {\n    greeting<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>–ü—Ä–∏–≤–µ—Ç<span class=\"pl-pds\">'</span></span>,\n  },\n}\n</code></pre><p>It is recommended to store messages in separate files on per-locale basis:</p><pre><code class=\"language-json5\"><span class=\"pl-c\">// en.json</span>\n{\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>greeting<span class=\"pl-pds\">\"</span></span><span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Hello<span class=\"pl-pds\">\"</span></span>\n}\n</code></pre><pre><code class=\"language-json5\"><span class=\"pl-c\">// ru.json</span>\n{\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>greeting<span class=\"pl-pds\">\"</span></span><span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>–ü—Ä–∏–≤–µ—Ç<span class=\"pl-pds\">\"</span></span>\n}\n</code></pre><p>Then import them in your configuration file:</p><pre><code class=\"language-ts\"><span class=\"pl-c\">// mfml.config.json</span>\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defineConfig</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/compiler<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> <span class=\"pl-smi\">en</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>./en.json<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">with</span> { type: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>json<span class=\"pl-pds\">'</span></span> };\n<span class=\"pl-k\">import</span> <span class=\"pl-smi\">ru</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>./ru.json<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">with</span> { type: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>json<span class=\"pl-pds\">'</span></span> };\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    <span class=\"pl-smi\">en</span>,\n    <span class=\"pl-smi\">ru</span>,\n  },\n});\n</code></pre><h2 id=\"outdir\"><a class=\"markdown-permalink\" href=\"#outdir\"><span class=\"icon icon-link\"></span></a><code>outDir</code></h2><p><strong>Default:</strong> The directory that contains the config file.</p><p>The directory that contains <em>node_modules</em> where a <a href=\"#packagename\">package</a> with compiled messages is written.</p><h2 id=\"packagename\"><a class=\"markdown-permalink\" href=\"#packagename\"><span class=\"icon icon-link\"></span></a><code>packageName</code></h2><p><strong>Default:</strong> <code>@mfml/messages</code></p><p>The name of the package where compiled messages are stored.</p><p>Specify a custom package name:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  packageName: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>my-messages<span class=\"pl-pds\">'</span></span>,\n  messages: {\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n});\n</code></pre><p>Import message functions from a custom package:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">renderToString</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>my-messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-en\">renderToString</span>({\n  message: <span class=\"pl-smi\">greeting</span>,\n  locale: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n});\n<span class=\"pl-c\">// ‚Æï 'Hello'</span>\n</code></pre><h2 id=\"fallbacklocales\"><a class=\"markdown-permalink\" href=\"#fallbacklocales\"><span class=\"icon icon-link\"></span></a><code>fallbackLocales</code></h2><p><strong>Default:</strong> <code>{}</code></p><p>Mapping from a locale to a corresponding fallback locale.</p><p>For example, let's consider <code>fallbackLocales</code> set to:</p><pre><code class=\"language-json5\">{\n  <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en-US<span class=\"pl-pds\">'</span></span><span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">'</span>ru-RU<span class=\"pl-pds\">'</span></span><span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>ru<span class=\"pl-pds\">'</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">'</span>ru<span class=\"pl-pds\">'</span></span><span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n}\n</code></pre><p>In this case:</p><ul><li><p>If a message doesn't support the <code>ru-RU</code> locale, the compiler will look for the <code>ru</code> locale.</p></li><li><p>If the <code>ru</code> locale isn't supported either, the compiler will fall back to the <code>en</code> locale.</p></li><li><p>If the <code>en</code> locale also isn't supported, the message function will return <code>null</code> when called with the <code>ru-RU</code> locale.</p></li></ul><p>It is safe to have loops in fallback locales:</p><pre><code class=\"language-json5\">{\n  en<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>ru<span class=\"pl-pds\">'</span></span>,\n  ru<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n}\n</code></pre><p>This setup would result in a fallback to <code>ru</code> for messages that don't support <code>en</code>, and a fallback to <code>en</code> for messages that don't support <code>ru</code>.</p><h2 id=\"preprocessors\"><a class=\"markdown-permalink\" href=\"#preprocessors\"><span class=\"icon icon-link\"></span></a><code>preprocessors</code></h2><p><strong>Default:</strong> <code>[]</code></p><p>The array of callbacks that are run <em>before</em> the message is parsed as an MFML AST.</p><p>Here's how to transform Markdown messages before compilation:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">marked</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>marked<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defineConfig</span>, <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Preprocessor</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/compiler<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">transformMarkdown</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Preprocessor</span> <span class=\"pl-k\">=</span> <span class=\"pl-v\">params</span> <span class=\"pl-k\">=></span> <span class=\"pl-smi\">marked</span>.<span class=\"pl-c1\">parse</span>(<span class=\"pl-smi\">params</span>.<span class=\"pl-c1\">text</span>);\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__Hello__<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n  preprocessors: [<span class=\"pl-smi\">transformMarkdown</span>],\n});\n</code></pre><p>The compiled <code>greeting</code> message would have the following markup:</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">p</span>>&#x3C;<span class=\"pl-ent\">strong</span>>Hello&#x3C;/<span class=\"pl-ent\">strong</span>>&#x3C;/<span class=\"pl-ent\">p</span>>\n</code></pre><h2 id=\"postprocessors\"><a class=\"markdown-permalink\" href=\"#postprocessors\"><span class=\"icon icon-link\"></span></a><code>postprocessors</code></h2><p><strong>Default:</strong> <code>[]</code></p><p>The array of callbacks that are run <em>after</em> the message was parsed as an MFML AST.</p><p>Preprocessors can be used to validate messages, rename arguments, or for other AST-based transformations.</p><p>Here's how to rename all message arguments before compilation:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">walkNode</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defineConfig</span>, <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Postprocessor</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/compiler<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">renameArguments</span><span class=\"pl-k\">:</span> <span class=\"pl-en\">Postprocessor</span> <span class=\"pl-k\">=</span> <span class=\"pl-v\">params</span> <span class=\"pl-k\">=></span> {\n  <span class=\"pl-en\">walkNode</span>(<span class=\"pl-smi\">params</span>.<span class=\"pl-smi\">messageNode</span>, <span class=\"pl-v\">node</span> <span class=\"pl-k\">=></span> {\n    <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">node</span>.<span class=\"pl-c1\">nodeType</span> <span class=\"pl-k\">===</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>argument<span class=\"pl-pds\">'</span></span>) {\n      <span class=\"pl-smi\">node</span>.<span class=\"pl-c1\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">node</span>.<span class=\"pl-c1\">name</span>.<span class=\"pl-c1\">toLowerCase</span>();\n    }\n  });\n\n  <span class=\"pl-k\">return</span> <span class=\"pl-smi\">params</span>.<span class=\"pl-smi\">messageNode</span>;\n};\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>{NAME} is {AGE, number} years old<span class=\"pl-pds\">'</span></span>,\n      <span class=\"pl-c\">//          ^^^^ üü° Upper case argument names</span>\n    },\n  },\n  postprocessors: [<span class=\"pl-smi\">renameArguments</span>],\n});\n</code></pre><p>The compiled <code>greeting</code> message function would have the following signature:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">greeting</span>(<span class=\"pl-v\">locale</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">string</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">MessageNode</span>&#x3C;{ <span class=\"pl-v\">name</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">unknown</span>; <span class=\"pl-v\">age</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">number</span> }> <span class=\"pl-k\">|</span> <span class=\"pl-c1\">null</span>;\n<span class=\"pl-c\">//                                               ^^^^ üü° Lower case argument names</span>\n</code></pre><h2 id=\"renamemessagefunction\"><a class=\"markdown-permalink\" href=\"#renamemessagefunction\"><span class=\"icon icon-link\"></span></a><code>renameMessage‚ÄãFunction</code></h2><p><strong>Default:</strong> <code>messageKey => messageKey</code></p><p>Returns the name of the message function for the given message key.</p><pre><code class=\"language-ts\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n  <span class=\"pl-en\">renameMessageFunction</span>: <span class=\"pl-v\">messageKey</span> <span class=\"pl-k\">=></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Bazinga_<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-smi\">messageKey</span>,\n});\n</code></pre><p>Import the message function with the altered name:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">renderToString</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">Bazinga_greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-en\">renderToString</span>({\n  locale: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n  message: <span class=\"pl-smi\">Bazinga_greeting</span>,\n});\n<span class=\"pl-c\">// ‚Æï 'Hello'</span>\n</code></pre><p>Message function names are always escaped; illegal characters are replaced with underscores.</p><p>Compilation fails if the same function name is generated for different message keys.</p><h2 id=\"decodetext\"><a class=\"markdown-permalink\" href=\"#decodetext\"><span class=\"icon icon-link\"></span></a><code>decodeText</code></h2><p><strong>Default:</strong> <a href=\"https://github.com/smikhalevski/speedy-entities#decode\"><code>decodeXML</code><span class=\"external\"></span></a></p><p>Decode the text content before it is pushed to an MFML AST node. Use this method to decode HTML entities.</p><p>By default, the compiler supports XML entities and numeric character references.</p><pre><code class=\"language-json\">{\n  <span class=\"pl-ent\">\"en\"</span>: {\n    <span class=\"pl-ent\">\"hotOrCold\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hot &#x26;gt; cold &#x26;#176;<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</code></pre><p>Provide a custom decoder to support HTML entities:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">decodeHTML</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>speedy-entities<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    en: {\n      hello: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>&#x26;CounterClockwiseContourIntegral;<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n  decodeText: <span class=\"pl-smi\">decodeHTML</span>,\n});\n</code></pre><div class=\"markdown-alert markdown-alert-tip\"><p class=\"markdown-alert-title\"><svg class=\"octicon octicon-light-bulb mr-2\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z\"></path></svg>Tip</p><p>Read more about <a href=\"https://github.com/smikhalevski/speedy-entities#readme\">speedy-entities<span class=\"external\"></span></a>, the fastest XML/HTML entity encoder/decoder in just 13 kB gzipped.</p></div><h2 id=\"getargumenttstype\"><a class=\"markdown-permalink\" href=\"#getargumenttstype\"><span class=\"icon icon-link\"></span></a><code>getArgumentTSType</code></h2><p><strong>Default:</strong> <a href=\"https://smikhalevski.github.io/mfml/functions/mfml_compiler.getIntlArgumentTSType.html\"><code>getIntlArgumentTSType</code><span class=\"external\"></span></a></p><p>Returns the TypeScript type for a given argument.</p><pre><code class=\"language-ts\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>{name} is {age, number} years old<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n\n  <span class=\"pl-en\">getArgumentTSType</span>(<span class=\"pl-v\">argumentNode</span>) {\n    <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">argumentNode</span>.<span class=\"pl-smi\">typeNode</span>?.<span class=\"pl-c1\">value</span> <span class=\"pl-k\">===</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>number<span class=\"pl-pds\">'</span></span>) {\n      <span class=\"pl-k\">return</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>number<span class=\"pl-pds\">'</span></span>;\n    }\n    <span class=\"pl-k\">return</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>string<span class=\"pl-pds\">'</span></span>;\n  },\n});\n</code></pre><p>This would produce a message function with the following signature:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">greeting</span>(<span class=\"pl-v\">locale</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">string</span>)<span class=\"pl-k\">:</span> <span class=\"pl-en\">MessageNode</span>&#x3C;{ <span class=\"pl-v\">name</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">string</span>; <span class=\"pl-v\">age</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">number</span> }> <span class=\"pl-k\">|</span> <span class=\"pl-c1\">null</span>;\n</code></pre><p>By default, <a href=\"https://smikhalevski.github.io/mfml/functions/mfml_compiler.getIntlArgumentTSType.html\"><code>getIntlArgumentTSType</code><span class=\"external\"></span></a> is used. It returns the TypeScript type of an argument that matches the requirements of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl\"><code>Intl</code><span class=\"external\"></span></a> formats.</p><table><thead><tr><th align=\"left\">Argument¬†type</th><th align=\"left\">TypeScript type</th></tr></thead><tbody><tr><td align=\"left\"><code>number</code></td><td align=\"left\"><code>number | bigint</code></td></tr><tr><td align=\"left\"><code>date</code></td><td align=\"left\"><code>number | Date</code></td></tr><tr><td align=\"left\"><code>time</code></td><td align=\"left\"><code>number | Date</code></td></tr><tr><td align=\"left\"><code>list</code></td><td align=\"left\"><code>string[]</code></td></tr><tr><td align=\"left\"><code>plural</code></td><td align=\"left\"><code>number</code></td></tr><tr><td align=\"left\"><code>selectOrdinal</code></td><td align=\"left\"><code>number</code></td></tr><tr><td align=\"left\"><code>select</code></td><td align=\"left\">A¬†union¬†of¬†category¬†name literals. <code>string &#x26; {}</code> is used for the <code>other</code> category.</td></tr></tbody></table><h2 id=\"tokenizeroptions\"><a class=\"markdown-permalink\" href=\"#tokenizeroptions\"><span class=\"icon icon-link\"></span></a><code>tokenizerOptions</code></h2><p><strong>Default:</strong> <a href=\"https://smikhalevski.github.io/mfml/variables/mfml_parser.htmlTokenizerOptions.html\"><code>htmlTokenizerOptions</code><span class=\"external\"></span></a></p><p>Options that define how MFML messages are tokenized. By default, forgiving HTML tokenizer options are used.</p><pre><code class=\"language-ts\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  messages: {\n    en: {\n      greeting: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>&#x3C;h1>Hello&#x3C;p>Dear diary<span class=\"pl-pds\">'</span></span>,\n    },\n  },\n  tokenizerOptions: {\n    implicitlyClosedTags: {\n      p: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>h1<span class=\"pl-pds\">'</span></span>],\n    },\n    isUnbalancedStartTagsImplicitlyClosed: <span class=\"pl-c1\">true</span>,\n  },\n});\n</code></pre><p>The compiled message would be:</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">h1</span>>Hello&#x3C;/<span class=\"pl-ent\">h1</span>>&#x3C;<span class=\"pl-ent\">p</span>>Dear diary&#x3C;/<span class=\"pl-ent\">p</span>>\n</code></pre><p>To partially override tokenizer options use spread:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">defineConfig</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/compiler<span class=\"pl-pds\">'</span></span>;\n<span class=\"pl-k\">import</span> { <span class=\"pl-smi\">htmlTokenizerOptions</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/parser<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">default</span> <span class=\"pl-en\">defineConfig</span>({\n  <span class=\"pl-c\">// messages: { ‚Ä¶ },</span>\n  tokenizerOptions: {\n    <span class=\"pl-k\">...</span><span class=\"pl-smi\">htmlTokenizerOptions</span>,\n    isOctothorpeRecognized: <span class=\"pl-c1\">false</span>,\n  },\n});\n</code></pre><p>Read more about tokenization in <a href=\"#tokenizing-messages\">Tokenizing messages</a> section.</p><h1 id=\"tokenizing-messages\"><a class=\"markdown-permalink\" href=\"#tokenizing-messages\"><span class=\"icon icon-link\"></span></a>Tokenizing messages</h1><p>Create a tokenizer using <a href=\"https://smikhalevski.github.io/mfml/functions/mfml_parser.createTokenizer.html\"><code>createTokenizer</code><span class=\"external\"></span></a> to read message as a sequence of tokens:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">createTokenizer</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/parser<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">tokenizer</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">createTokenizer</span>();\n\n<span class=\"pl-smi\">tokenizer</span>.<span class=\"pl-en\">tokenize</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello, &#x3C;b>{name}&#x3C;/b>!<span class=\"pl-pds\">'</span></span>, (<span class=\"pl-v\">token</span>, <span class=\"pl-v\">startIndex</span>, <span class=\"pl-v\">endIndex</span>) <span class=\"pl-k\">=></span> {\n  <span class=\"pl-c\">// Handle tokens here</span>\n});\n</code></pre><p>The callback is called with the following arguments:</p><table><thead><tr><th align=\"left\"><code>token</code></th><th align=\"right\"><code>startIndex</code></th><th align=\"right\"><code>endIndex</code></th><th align=\"left\">Corresponding¬†substring</th></tr></thead><tbody><tr><td align=\"left\"><code>'TEXT'</code></td><td align=\"right\">0</td><td align=\"right\">7</td><td align=\"left\"><code>'Hello,¬†'</code></td></tr><tr><td align=\"left\"><code>'START_TAG_NAME'</code></td><td align=\"right\">8</td><td align=\"right\">9</td><td align=\"left\"><code>'b'</code></td></tr><tr><td align=\"left\"><code>'START_TAG_CLOSING'</code></td><td align=\"right\">9</td><td align=\"right\">10</td><td align=\"left\"><code>'>'</code></td></tr><tr><td align=\"left\"><code>'ARGUMENT_NAME'</code></td><td align=\"right\">11</td><td align=\"right\">15</td><td align=\"left\"><code>'name'</code></td></tr><tr><td align=\"left\"><code>'ARGUMENT_CLOSING'</code></td><td align=\"right\">15</td><td align=\"right\">16</td><td align=\"left\"><code>'}'</code></td></tr><tr><td align=\"left\"><code>'END_TAG_NAME'</code></td><td align=\"right\">18</td><td align=\"right\">19</td><td align=\"left\"><code>'b'</code></td></tr><tr><td align=\"left\"><code>'TEXT'</code></td><td align=\"right\">20</td><td align=\"right\">21</td><td align=\"left\"><code>'!'</code></td></tr></tbody></table><p>Tokens are <em>guaranteed</em> to be returned in correct order or a <a href=\"https://smikhalevski.github.io/mfml/classes/mfml_parser.ParserError.html\"><code>ParserError</code><span class=\"external\"></span></a> is thrown. Missing tokens can be inserted to restore the correct order if needed, depending on provided tokenizer option.</p><p>Create a tokenizer with a custom set of options:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">const</span> <span class=\"pl-c1\">tokenizer</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">createTokenizer</span>({\n  isUnbalancedStartTagsImplicitlyClosed: <span class=\"pl-c1\">true</span>,\n});\n</code></pre><p>MFML provides a preconfigured forgiving HTML tokenizer <a href=\"https://smikhalevski.github.io/mfml/variables/mfml_parser.htmlTokenizer.html\"><code>htmlTokenizer</code><span class=\"external\"></span></a> and corresponding set of options <a href=\"https://smikhalevski.github.io/mfml/variables/mfml_parser.htmlTokenizerOptions.html\"><code>htmlTokenizerOptions</code><span class=\"external\"></span></a>:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">createTokenizer</span>, <span class=\"pl-smi\">htmlTokenizerOptions</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/parser<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">tokenizer</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">createTokenizer</span>(<span class=\"pl-smi\">htmlTokenizerOptions</span>);\n<span class=\"pl-c\">// Same as htmlTokenizer</span>\n</code></pre><h2 id=\"voidtags\"><a class=\"markdown-permalink\" href=\"#voidtags\"><span class=\"icon icon-link\"></span></a><code>voidTags</code></h2><p><strong>Default:</strong> <code>[]</code></p><p>The list of tags that can't have any contents (since there's no end tag, no content can be put between the start tag and the end tag).</p><pre><code class=\"language-ts\"><span class=\"pl-en\">createTokenizer</span>({\n  voidTags: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>img<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>link<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>meta<span class=\"pl-pds\">'</span></span>],\n});\n</code></pre><p>See <a href=\"https://www.w3.org/TR/2010/WD-html5-20101019/syntax.html#void-elements\">HTML5 Void Elements<span class=\"external\"></span></a> for more info.</p><h2 id=\"rawtexttags\"><a class=\"markdown-permalink\" href=\"#rawtexttags\"><span class=\"icon icon-link\"></span></a><code>rawTextTags</code></h2><p><strong>Default:</strong> <code>[]</code></p><p>The list of tags which content is interpreted as plain text. Tags inside raw text tag are treated as plain text.</p><pre><code class=\"language-ts\"><span class=\"pl-en\">createTokenizer</span>({\n  rawTextTags: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>script<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>style<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>plaintext<span class=\"pl-pds\">'</span></span>],\n});\n</code></pre><p>See <a href=\"https://www.w3.org/TR/2010/WD-html5-20101019/syntax.html#raw-text-elements\">HTML5 Raw Text Elements<span class=\"external\"></span></a> for more info.</p><h2 id=\"implicitlyclosedtags\"><a class=\"markdown-permalink\" href=\"#implicitlyclosedtags\"><span class=\"icon icon-link\"></span></a><code>implicitlyClosedTags</code></h2><p><strong>Default:</strong> <code>{}</code></p><p>The map from a tag to a list of tags that must be closed if it is opened.</p><p>For example, in HTML <code>p</code> and <code>h1</code> tags have the following semantics:</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">p</span>>&#x3C;<span class=\"pl-ent\">h1</span>>&#x3C;/<span class=\"pl-ent\">h1</span>> ‚Æï &#x3C;<span class=\"pl-ent\">p</span>>&#x3C;/<span class=\"pl-ent\">p</span>>&#x3C;<span class=\"pl-ent\">h1</span>>&#x3C;/<span class=\"pl-ent\">h1</span>>\n                   ^^^\n</code></pre><p>To achieve this behavior, set this option to:</p><pre><code class=\"language-ts\"><span class=\"pl-en\">createTokenizer</span>({\n  implicitlyClosedTags: {\n    <span class=\"pl-c\">// h1 implicitly closes p</span>\n    h1: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>p<span class=\"pl-pds\">'</span></span>],\n  },\n});\n</code></pre><p>Use in conjunctions with <a href=\"#isunbalancedstarttagsimplicitlyclosed\"><code>isUnbalancedStartTags‚ÄãImplicitlyClosed</code></a>.</p><h2 id=\"implicitlyopenedtags\"><a class=\"markdown-permalink\" href=\"#implicitlyopenedtags\"><span class=\"icon icon-link\"></span></a><code>implicitlyOpenedTags</code></h2><p><strong>Default:</strong> <code>[]</code></p><p>The list of tags for which a start tag is inserted if an unbalanced end tag is met. Otherwise, a <a href=\"https://smikhalevski.github.io/mfml/classes/mfml_parser.ParserError.html\"><code>ParserError</code><span class=\"external\"></span></a> is thrown.</p><p>You can ignore unbalanced end tags with <a href=\"#isunbalancedendtagsignored\"><code>isUnbalancedEndTagsIgnored</code></a>.</p><p>For example, in HTML <code>p</code> tag follow this semantics:</p><pre><code class=\"language-html\">&#x3C;/<span class=\"pl-ent\">p</span>>  ‚Æï &#x3C;<span class=\"pl-ent\">p</span>>&#x3C;/<span class=\"pl-ent\">p</span>>\n            ^^^\n</code></pre><p>To achieve this behavior, set this option to:</p><pre><code class=\"language-ts\"><span class=\"pl-en\">createTokenizer</span>({\n  implicitlyOpenedTags: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>p<span class=\"pl-pds\">'</span></span>],\n});\n</code></pre><h2 id=\"iscaseinsensitivetags\"><a class=\"markdown-permalink\" href=\"#iscaseinsensitivetags\"><span class=\"icon icon-link\"></span></a><code>isCaseInsensitive‚ÄãTags</code></h2><p><strong>Default:</strong> <code>false</code></p><p>If <code>true</code> then [A-Z] characters are case-insensitive in tag names.</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">em</span>>&#x3C;/<span class=\"pl-ent\">EM</span>> ‚Æï &#x3C;<span class=\"pl-ent\">em</span>>&#x3C;/<span class=\"pl-ent\">em</span>>\n                  ^^^\n</code></pre><h2 id=\"isselfclosingtagsrecognized\"><a class=\"markdown-permalink\" href=\"#isselfclosingtagsrecognized\"><span class=\"icon icon-link\"></span></a><code>isSelfClosingTags‚ÄãRecognized</code></h2><p><strong>Default:</strong> <code>false</code></p><p>If <code>true</code> then self-closing tags are recognized, otherwise they are treated as start tags.</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">link</span> />\n      ^\n</code></pre><h2 id=\"isunbalancedstarttagsimplicitlyclosed\"><a class=\"markdown-permalink\" href=\"#isunbalancedstarttagsimplicitlyclosed\"><span class=\"icon icon-link\"></span></a><code>isUnbalancedStart‚ÄãTags‚ÄãImplicitly‚ÄãClosed</code></h2><p><strong>Default:</strong> <code>false</code></p><p>If <code>true</code> then unbalanced start tags are forcefully closed. Otherwise, a <a href=\"https://smikhalevski.github.io/mfml/classes/mfml_parser.ParserError.html\"><code>ParserError</code><span class=\"external\"></span></a> is thrown.</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">a</span>>&#x3C;<span class=\"pl-ent\">b</span>>&#x3C;/<span class=\"pl-ent\">a</span>> ‚Æï &#x3C;<span class=\"pl-ent\">a</span>>&#x3C;<span class=\"pl-ent\">b</span>>&#x3C;/<span class=\"pl-ent\">b</span>>&#x3C;/<span class=\"pl-ent\">a</span>>\n                    ^^^\n</code></pre><p>Use in conjunctions with <a href=\"#isunbalancedendtagsignored\"><code>isUnbalancedEndTagsIgnored</code></a>.</p><h2 id=\"isunbalancedendtagsignored\"><a class=\"markdown-permalink\" href=\"#isunbalancedendtagsignored\"><span class=\"icon icon-link\"></span></a><code>isUnbalancedEndTags‚ÄãIgnored</code></h2><p><strong>Default:</strong> <code>false</code></p><p>If <code>true</code> then end tags that don't have a corresponding start tag are ignored. Otherwise, a <a href=\"https://smikhalevski.github.io/mfml/classes/mfml_parser.ParserError.html\"><code>ParserError</code><span class=\"external\"></span></a> is thrown.</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">a</span>>&#x3C;/<span class=\"pl-ent\">b</span>>&#x3C;/<span class=\"pl-ent\">a</span>> ‚Æï &#x3C;<span class=\"pl-ent\">a</span>>&#x3C;/<span class=\"pl-ent\">a</span>>\n    ^^^\n</code></pre><p>Use in conjunctions with <a href=\"#isunbalancedstarttagsimplicitlyclosed\"><code>isUnbalancedStartTagsImplicitlyClosed</code></a>.</p><h2 id=\"israwtextinterpolated\"><a class=\"markdown-permalink\" href=\"#israwtextinterpolated\"><span class=\"icon icon-link\"></span></a><code>isRawText‚ÄãInterpolated</code></h2><p><strong>Default:</strong> <code>false</code></p><p>If <code>true</code> then arguments are parsed inside <a href=\"#rawtexttags\"><code>rawTextTags</code></a>.</p><p>Here's how to add a raw text tag:</p><pre><code class=\"language-ts\"><span class=\"pl-en\">createTokenizer</span>({\n  rawTextTags: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>plaintext<span class=\"pl-pds\">'</span></span>],\n  isRawTextInterpolated: <span class=\"pl-c1\">true</span>,\n});\n</code></pre><p>An argument inside the <code>&#x3C;plaintext></code> tag is interpolated:</p><pre><code class=\"language-html\">&#x3C;<span class=\"pl-ent\">plaintext</span>>{name}&#x3C;/<span class=\"pl-ent\">plaintext</span>>\n           ^^^^^^\n</code></pre><h2 id=\"isoctothorperecognized\"><a class=\"markdown-permalink\" href=\"#isoctothorperecognized\"><span class=\"icon icon-link\"></span></a><code>isOctothorpe‚ÄãRecognized</code></h2><p><strong>Default:</strong> <code>false</code></p><p>If <code>true</code> then an octothorpe character <code>#</code> inside an argument category is replaced with the argument value.</p><pre><code>{gender, select, male { He is a # } female { She is a # }}\n                                                      ^\n</code></pre><h1 id=\"parsing-messages\"><a class=\"markdown-permalink\" href=\"#parsing-messages\"><span class=\"icon icon-link\"></span></a>Parsing messages</h1><p>Create a parser using <a href=\"https://smikhalevski.github.io/mfml/functions/mfml_parser.createParser.html\"><code>createParser</code><span class=\"external\"></span></a>:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">createParser</span>, <span class=\"pl-smi\">htmlTokenizer</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml/parser<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">parser</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">createParser</span>({ tokenizer: <span class=\"pl-smi\">htmlTokenizer</span> });\n</code></pre><p>Parser converts a message text into an AST by consuming tokens produced by a tokenizer. Read more about message tokenization in <a href=\"#tokenizing-messages\">Tokenizing messages</a> section.</p><p>Parse a message as an AST:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">const</span> <span class=\"pl-c1\">messageNode</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">parser</span>.<span class=\"pl-c1\">parse</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello, &#x3C;b>{name}&#x3C;/b>!<span class=\"pl-pds\">'</span></span>);\n</code></pre><p>This returns a <a href=\"https://smikhalevski.github.io/mfml/interfaces/mfml.MessageNode.html\"><code>MessageNode</code><span class=\"external\"></span></a> instance that looks like this:</p><pre><code class=\"language-json5\">{\n  nodeType<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>message<span class=\"pl-pds\">'</span></span>,\n  parentNode<span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>,\n  locale<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>en<span class=\"pl-pds\">'</span></span>,\n  childNodes<span class=\"pl-k\">:</span> [\n    {\n      nodeType<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>text<span class=\"pl-pds\">'</span></span>,\n      parentNode<span class=\"pl-k\">:</span> { <span class=\"pl-c\">/* Cyclic reference to the message node */</span> },\n      value<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Hello, <span class=\"pl-pds\">'</span></span>,\n      startIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">0</span>,\n      endIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">7</span>,\n    },\n    {\n      nodeType<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>element<span class=\"pl-pds\">'</span></span>,\n      parentNode<span class=\"pl-k\">:</span> { <span class=\"pl-c\">/* Cyclic reference to the message node */</span> },\n      tagName<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>,\n      attributeNodes<span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>,\n      childNodes<span class=\"pl-k\">:</span> [\n        {\n          nodeType<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>argument<span class=\"pl-pds\">'</span></span>,\n          parentNode<span class=\"pl-k\">:</span> { <span class=\"pl-c\">/* Cyclic reference to the element node */</span> },\n          name<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>name<span class=\"pl-pds\">'</span></span>,\n          typeNode<span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>,\n          styleNode<span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>,\n          optionNodes<span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>,\n          categoryNodes<span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>,\n          startIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">11</span>,\n          endIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">15</span>,\n        },\n      ],\n      startIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">8</span>,\n      endIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">9</span>,\n    },\n    {\n      nodeType<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>text<span class=\"pl-pds\">'</span></span>,\n      parentNode<span class=\"pl-k\">:</span> { <span class=\"pl-c\">/* Cyclic reference to the message node */</span> },\n      value<span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>!<span class=\"pl-pds\">'</span></span>,\n      startIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">20</span>,\n      endIndex<span class=\"pl-k\">:</span> <span class=\"pl-c1\">21</span>,\n    },\n  ],\n}\n</code></pre><p>MFML AST can be analyzed at runtime and rendered in any way you want. In <a href=\"#quick-start\">Quick start</a> section we showed how messages can be compiled into message functions. A message function returns an AST that describes a message:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">greeting</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>@mfml/messages<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">messageNode</span> <span class=\"pl-k\">=</span> <span class=\"pl-en\">greeting</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>en-US<span class=\"pl-pds\">'</span></span>);\n</code></pre><p>Use <a href=\"https://smikhalevski.github.io/mfml/functions/mfml.walkNode.html\"><code>walkNode</code><span class=\"external\"></span></a> to traverse AST:</p><pre><code class=\"language-ts\"><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">walkNode</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mfml<span class=\"pl-pds\">'</span></span>;\n\n<span class=\"pl-en\">walkNode</span>(<span class=\"pl-smi\">messageNode</span>, <span class=\"pl-v\">node</span> <span class=\"pl-k\">=></span> {\n  <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">node</span>.<span class=\"pl-c1\">nodeType</span> <span class=\"pl-k\">===</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>argument<span class=\"pl-pds\">'</span></span>) {\n    <span class=\"pl-c\">// Handle argument node</span>\n  }\n});\n</code></pre><h1 id=\"motivation\"><a class=\"markdown-permalink\" href=\"#motivation\"><span class=\"icon icon-link\"></span></a>Motivation</h1><p>The main idea is that i18n messages are part of the code, and the application's code should be split into dynamically loaded chunks that include the required translations. When translations change, a new version of the application should be released.</p><p>Splitting the app code into chunks and loading those chunks at runtime is usually handled by a bundler. Modern i18n tools, such as <code>i18next</code>, rely on JSON files that are either baked into the application bundle or loaded asynchronously. This approach has several downsides:</p><ul><li><p>You must split your messages into separate JSON files before bundling. Otherwise, clients will have to download all messages when the application starts.</p></li><li><p>You need to load messages manually when they're required.</p></li><li><p>Unused messages remain bundled and loaded unless you remove them manually.</p></li><li><p>Errors, such as missing interpolation parameters or invalid parameter types, are only caught at runtime.</p></li></ul><p>All of the above is highly error-prone due to human factors.</p><p>MFML compiles messages into functions that can be imported as modules in your code. This approach offers multiple benefits:</p><ul><li><p>Message functions are bundled and loaded together with your code, so you don't need to manage translation loading manually.</p></li><li><p>Message functions are tree-shakeable, ensuring that the chunks produced by the bundler contain only the translations actually used.</p></li><li><p>Message functions can be type-checked at compile time. This ensures you won't forget required parameters or use parameters of the wrong type. If a message key changes, the modules importing the corresponding message function will need to be updated ‚Äî otherwise, the type checker or bundler will alert you that the imported function is missing.</p></li><li><p>Message functions use a runtime to render the message. The runtime can produce React elements, plain strings, or any other output format you need.</p></li></ul>"}